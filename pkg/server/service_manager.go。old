// service registration and discovery

package server

import (
	"encoding/json"
	"io/ioutil"
	"math/rand"
	"net/http"
	"sort"
	"strings"
	"time"
)old

// services' address
var serverIpMap map[string]string = make(map[string]string)

type ValueStruct struct {
	Key           string   `json:"key"`
	Value         string   `json:"value"`
	ModifiedIndex int      `json:"modifiedIndex"`
	CreatedIndex  int      `json:"createdIndex"`
	Nodes         ValueLst `json:"nodes"`
}

type NodeStruct struct {
	Key           string   `json:"key"`
	ModifiedIndex int      `json:"modifiedIndex"`
	CreatedIndex  int      `json:"createdIndex"`
	Nodes         ValueLst `json:"nodes"`
}

type EtcdResponse struct {
	Action string     `json:"action"`
	Node   NodeStruct `json:"node"`
}

type MasterManager struct {
	serverName string
	mapServers map[string][]string
	cfg        *config.Config
}

type ValueLst []ValueStruct

func (list ValueLst) Len() int {
	return len(list)
}

func (list ValueLst) Less(i, j int) bool {
	if list[i].Value < list[j].Value {
		return true
	}

	return false
}

func (list ValueLst) Swap(i, j int) {
	list[i], list[j] = list[j], list[i]
}

func NewMasterManager(name string, conf *config.Config) (*MasterManager, error) {
	return &MasterManager{
		serverName: name,
		cfg:        conf,
	}, nil
}

// register server to master
func (mgr *MasterManager) RegisterServer() error {
	if mgr.cfg == nil {
		return errorf("MasterManager cfg field is nil ")
	}

	// master_server is config as: ip1;ip2;ip3
	configAddrss, err := mgr.cfg.String(cfgRPCRemoteSection, "master_server")
	if err != nil {
		return err
	}

	addrs := strings.Split(configAddrss, ";")
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	offset := r.Intn(len(addrs))
	for i := 0; i < len(addrs); i++ {
		idx := (i + offset) % len(addrs)
		addr := addrs[idx]

		flag := true
		allSection := []string{cfgRPCServerSection, cfgTCPServerSection, cfgHTTPServerSection}
		for _, section := range allSection {
			host, err := mgr.cfg.String(section, "host")
			if err != nil {
				continue
			}
			host, _, err = fixHostIp(host)
			if err != nil {
				return errorf("%s host is not correct: %s", section, host)
			}

			url := "http://" + addr + "/v2/keys/pando_server/" + mgr.serverName + "_" + section + "/" + host
			client := &http.Client{}
			request, err := http.NewRequest("PUT", url, strings.NewReader("ttl=180&value="+getInnerIp()))
			if err != nil {
				flag = false
				break
			}
			request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
			rsp, err := client.Do(request)
			if rsp != nil {
				defer rsp.Body.Close()
			}
			if err != nil {
				flag = false
				break
			}
		}

		if flag {
			return nil
		}
	}

	return errorf("register all master server failed")
}

// update server hosts
func (mgr *MasterManager) UpdateServerHosts() error {
	if mgr.cfg == nil {
		return errorf("MasterManager cfg field is nil ")
	}

	// master_server is config as: ip1;ip2;ip3
	configAddrss, err := mgr.cfg.String(cfgRPCRemoteSection, "master_server")
	if err != nil {
		return err
	}

	addrs := strings.Split(configAddrss, ";")
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	offset := r.Intn(len(addrs))
	for i := 0; i < len(addrs); i++ {
		idx := (i + offset) % len(addrs)
		addr := addrs[idx]

		client := &http.Client{}
		request, err := http.NewRequest("GET", "http://"+addr+"/v2/keys/pando_server?recursive=true", nil)
		if err != nil {
			continue
		}
		response, err := client.Do(request)
		if response != nil {
			defer response.Body.Close()
		}
		if err != nil {
			continue
		}

		if response.StatusCode != 200 {
			continue
		}

		body, err := ioutil.ReadAll(response.Body)
		if err != nil {
			continue
		}
		bodystr := string(body)
		var res EtcdResponse
		err = json.Unmarshal([]byte(bodystr), &res)
		if err != nil {
			continue
		}

		servers := make(map[string][]string)
		for _, node := range res.Node.Nodes {
			serverType := strings.Split(node.Key, "/")[2]
			servers[serverType] = []string{}
			sort.Sort(node.Nodes)
			for _, ip := range node.Nodes {
				servers[serverType] = append(servers[serverType], strings.Split(ip.Key, "/")[3])
			}
		}

		// sort the iplist for servers
		for _, lst := range servers {
			for i := 0; i < len(lst); i++ {
				for j := i + 1; j < len(lst); j++ {
					if lst[i] > lst[j] {
						lst[i], lst[j] = lst[j], lst[i]
					}
				}
			}
		}

		mgr.mapServers = servers

		return nil
	}

	return errorf("update from all master server failed")
}

// get host ips for the server, now return two ips
func (mgr *MasterManager) GetServerHosts(serverType string, index uint64) ([]string, error) {
	ips, ok := mgr.mapServers[serverType]
	if !ok || len(ips) == 0 {
		// try update server hosts mannually
		mgr.UpdateServerHosts()
	}
	ips, ok = mgr.mapServers[serverType]
	if !ok || len(ips) == 0 {
		return nil, errorf("no ips for %s", serverType)
	}
	retIps := []string{}
	idx := int(index % uint64(len(ips)))
	retIps = append(retIps, ips[idx])

	if len(ips) > 1 {
		retIps = append(retIps, ips[(idx+1)%len(ips)])
	}

	return retIps, nil
}
